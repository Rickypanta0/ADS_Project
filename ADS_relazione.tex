\documentclass[a4paper]{article}
\usepackage[italian]{babel}

% immagini
\usepackage{graphicx}
\usepackage{svg}
\usepackage{amsthm}

% matematica
\usepackage{amsmath}
\usepackage{amsfonts}

% codice
\usepackage{listings}
\lstset{
    basicstyle=\small\ttfamily,
    numbers=left,
    numberstyle=\small\ttfamily
}

\usepackage{blindtext}
\usepackage{titlesec}
\usepackage{geometry}
\usepackage{relsize}
\usepackage{tikz}
% \geometry{
% a4paper,
% total={190mm,257mm},
% left=25mm,
% right=25mm,
% top=50mm,
% }


\sloppy % ?

\begin{document}

\begin{titlepage} % pagina riservata al titolo
    \begin{center}
        \vspace*{1cm}
        {\Huge\bfseries Analisi di algoritmi di selezione\par}
        \vspace{.5cm}
        {\LARGE Progetto di laboratorio di Algoritmi e Strutture Dati\par}
        \vspace{1cm}
        \begin{figure}[h]
            \centering
            \includegraphics[width=.5\textwidth]{photo/uniud_logo.png}
        \end{figure}
        \vspace{1.5cm}
        {\LARGE Università degli studi di Udine\par}
        {\LARGE Dipartimento di scienze Informatiche, Matematiche e Fisiche\par}
        \vfill
        {\Large Anno Accademico 2023/2024\par}
        {\Large Matricole: 162367, 162473\par}
        {\Large\itshape Gerardi Ludovico, Sclauzero Lorenzo, Pantanali Riccardo\par}
    \end{center}
\end{titlepage}
\newpage
\section{Introduzione}
Il progetto ha come scopo l'implementazione ed analizzare la complessità di tre algoritmi di selezione. Che calcolano il k-esimo elemento più piccolo di un vettore non ordinato di interi.\\
L'analisi dell'efficienza dei tre algoritmi viene effettuata attraverso la misurazione dei tempi medi\\
I tre algoritmi discussi all'interno della relazione per la risoluzione del problema prendono il nome di $Quick\ Select$, $Heap\ Select$ e $Medians\ of\ Medians$: come si vedrà nei prossimi paragrafi, le diverse procedure adottano dei metodi molto diversi questa differenza di approcci vengono riflesse nei grafici.\\
\section{Presentazione degli Algoritmi}
\subsection{Algoritmi calcolo k-esimo elemento}
\textbf{Quick Select}\ La procedura in ogni chiamata ricorsiva su un intervallo $[i,j]$
 del vettore fornito in input termina restituendo il $k-esimo$ elemento più piccolo del vettore qualora $k-1\in[i,j]$, oppure un valore indefinito qualora k$\not\in[i,j]$. L'algoritmo ha una complessità asintotica di $\Theta(n^2)$
 nel caso pessimo e $O(n)$ nel caso medio, dove $n$ è il numero di elementi del 
 \vspace{2mm}
 vettore.\\
\textbf{Heap Select}\ Questo algoritmo di selezione utilizza due min$-$heap, denominate H1 e H2. La prima heap H1 é costruita a partire dal vettore fornito in input in tempo lineare e non viene modificata.
La seconda heap \( H2 \) contiene inizialmente un solo nodo, corrispondente alla radice di \( H1 \). La minheap H2 sarà MaxHeap oppure MinHeap a seconda dei k, questa decisione si tramuterà in un netto miglioramento delle prestazioni (sez. 4). All'i-esima iterazione, per \( i \) che va da 1 a \( k-1 \), l'algoritmo estrae la radice di \( H2 \), che corrisponde a un nodo \( x_i \) in \( H1 \), e reinserisce in \( H2 \) i nodi successori (figli sinistro e destro) di \( x_i \) nella heap \( H1 \). Dopo \( k-1 \) iterazioni, la radice di \( H2 \) corrisponderà al \( k-esimo \) elemento più piccolo del vettore fornito in input.
L'algoritmo descritto ha complessità temporale $O(n+klogk)$\\
\vspace{2mm}
sia nel caso pessimo che in quello medio.\\\textbf{Medians of Medians}\ L'algoritmo descritto è un algoritmo basato sulla suddivisione di un vettore in blocchi di dimensione limitata (5 elementi), il calcolo della mediana di ciascun blocco e il calcolo della mediana delle mediane dei blocchi stessi. Questa mediana viene utilizzata per partizionare l'array attorno ad essa, similmente alla procedura "partition" dell'algoritmo "quick sort". A seconda del valore \( k \) fornito in input, l'algoritmo esegue chiamate ricorsive sulla parte sinistra o destra dell'array rispetto alla mediana calcolata. 

Sono proposti tre diversi approcci:
\begin{enumerate}
    \item Ricorsivo: Che alloca un nuovo vettore ad ogni chiamata ricorsiva per memorizzare le mediane dei blocchi.
    \item Quasi in place: Riutilizza lo spazio allocato per il vettore originariamente fornito in input.
    \item In place: Privo di chiamate ricorsive e riutilizza lo spazio del vettore originario.
\end{enumerate}
In tutti i casi, la complessità temporale e spaziale dell'algoritmo nel caso pessimo è \( O(n) \). Nei grafici della sezione 4 verrà utilizzata la versione quasi in Place.\\
\\
\subsection{Algoritmo per la generazione dei vettori}
La lunghezza n dell'array è compresa tra [100,100000].
A tale scopo, è possibile utilizzare un ciclo for con un indice $i$=0,...,99, e attraverso una funzione esponenziale di $i$ per generare le lunghezze n
, $n_i=\lfloor A*B^i\rfloor$ , dove A e B sono costanti in virgola mobile.\\
Nel nostro caso \[n_i=\lfloor A*B^i\rfloor, A=100, B=10000^{\frac{1}{100-1}},i=0,...,99\]
\section{Misurazione dei tempi di esecuzione}
La misurazione dei tempi necessari per calcolare il k-esimo numero in un array viene effettuata considerando la lunghezza \( n \) dell'array di input e l'errore massimo consentito. Per ogni lunghezza dell'array, gli algoritmi implementati ripetono il calcolo del k-esimo numero un numero di volte tale da garantire un errore massimo relativo pari a \( f_{\max} = 0.001 \), assicurando così un tempo totale maggiore o uguale a \( T_{\min} \), calcolato come \[ T_{\min} = R \left( \frac{1}{f} + 1 \right) \] dove \( R \) rappresenta la risoluzione del clock.

Ciascuna iterazione del calcolo del k-esimo numero viene eseguita su un array generato pseudo-casualmente di lunghezza \( n \), differente ad ogni iterazione.
\newpage
\section{Rappresentazione grafica dei risultati}
\subsection{Caso k costante}
\begin{figure}[h]
            \centering
            \includegraphics[width=.83\textwidth]{graphs/k_const_n.png}
            \includegraphics[width=.83\textwidth]{graphs/k_const_2xlog.png}
\end{figure}
Come si può notare dai grafici, con $k=\frac{n}{2}$ l'algoritmo $HeapSelect$ risulta essere quello con prestazioni peggiori tra i tre assumendo un andamento dell'oridine di $klogk$.
$Medians\ Of\ Medians$ e $Quick\ Select$ hanno entrambi complessita $O(n)$ però $MoM$ ha un andamento peggiore a causa degli ulteriori calcoli per determinare la mediana delle mediane.\\
\newpage
\begin{figure}[h]
            \centering
            \includegraphics[width=.83\textwidth]{graphs/k_last_n.png}
            \includegraphics[width=.83\textwidth]{graphs/k_last_2xlog.png}
\end{figure}
Come si evince dal grafico nel caso in cui $k$ risulti posizionarisi a uno dei due estremi del vettore porta a un netto miglioramento delle perfomance da parte di $Heap\ Select$.\\
Questo è dovuto dal fatto come spiegato nella sezione 2.1 che a seconda della posizione di k se $k\in[0,\frac{n}{2}]$ viene adottata una MinHeap mentre se $k\in[\frac{n}{2}+1,n-1]$ viene utilizzata un MaxHeap, adottando un andamento lineare nel caso in cui k tenda agli estremi del vettore.\\
Mentre gli andamenti di $MoM$ e $Quick\ Select$ rimangono invarianti.\\
\newpage
\subsection{Caso k random}
\begin{figure}[h]
            \centering
            \includegraphics[width=.83\textwidth]{graphs/k_random_n.png}
            \includegraphics[width=.83\textwidth]{graphs/k_random_2xlog.png}
\end{figure}
Dai grafici soprastanti e da quelli precedente mostrati si rende ancora più evidente la quasi indipendenza di $MoM$ e $Quick\ Select$ dalla posizione di k. Al contrario invece si evidenzia la netta dipendenza della complessità di $Heap\ Select$ dovuta dalla posizione di k e in questo caso la sua imprevedibilità.\\
\newpage
\subsection{Caso n fissato e k variato}
\begin{figure}[h]
    \centering
    \includegraphics[width=.83\textwidth]{graphs/n_fixex_n.png}
    \includegraphics[width=.83\textwidth]{graphs/n_fixed_2xlog.png}
\end{figure}
Da questi particolari grafici con k varia seguendo una serie geometrica, che permette di distribuire i suoi valori in maniera esponenziale, mentre la lunghezza del vettore è fissa a n=10000. Si noti in maniera ancora più marcata della totale dipendenza dell'andamento di $Heap\ Select$ al valore k, difatto l'algoritmo mostra un comportamento monotono crescente per $k\in[0,\frac{n}{2}]$ raggiungendo un massimo a $k=\frac{n}{2}$. 
Successivamente l'algoritmo mostra un andamento monotono decrescente per $k\in[\frac{n}{2}+1,n-1]$, andandosi ad allineare con $MoM$ all avvicinarsi agli estremi del vettore. Riguardo ad $Quick\ Select$ e $MoM$ non traspare nulla di differente da quello che abbiamo già evidenziato nelle sezioni precedenti.\\
\newpage
\section{Confronto tra MoM}
\begin{figure}[h]
    \centering
    \includegraphics[width=.83\textwidth]{graphs/MoMs_n.png}
    \includegraphics[width=.83\textwidth]{graphs/MoMs_2xlog.png}
\end{figure}
Come si può notare i tre algoritmi hanno degli andamenti molto simili sopratutto le due versioni place e quasi in place. Invece la versione non in place a causa delle chiamate ricorsive e dell'utilizzo di due array supplementari si rivela essere meno prestante al crescere della lunghezza dell'array.\\
\end{document}